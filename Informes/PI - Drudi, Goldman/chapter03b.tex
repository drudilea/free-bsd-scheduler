\subsection{Módulo de encendido/apagado de los procesadores}
Partiendo de un sistema operativo funcional y actualizado, el siguiente enfoque fue implementar una nueva característica que se encuentra dentro del área de ahorro energético y control de los núcleos del procesador.\par

Más precisamente lo que se busca, es poder controlar el estado de cada núcleo del procesador en el que se está ejecutando el sistema operativo, es decir, tener el control para elegir cuál o cuáles núcleos permitirán encolar y ejecutar hilos de procesos en diferentes momentos temporales y a su vez, que ésto pueda cambiar dinámicamente de acuerdo a las necesidades del sistema o a definiciones especificadas por el desarrollador.\par


\subsubsection{Objetivos}

Como objetivo general se propone crear una funcionalidad propia del scheduler para permitir habilitar o inhabilitar los diferentes núcleos del procesador, con el objetivo de trasfondo de ahorrar energía en contextos que así lo requieran.\par

A partir del objetivo mencionado anteriormente, podemos destacar diferentes situaciones inherentes al mismo, para dejar en evidencia las ventajas de éste módulo.\par

Es necesario partir de la suposición de que ésta funcionalidad será utilizada en diversos casos. Por ejemplo, cuando el procesador tenga pocas tareas o que las mismas no precisen de una gran capacidad de procesamiento, por lo que podrían ser resueltas con menos núcleos que el total disponible en el sistema.\par

Otro escenario podría basarse simplemente en la decisión de restringir la cantidad de núcleos disponibles de un sistema, por lo cual se elegiría inhabilitar los demás y de ésta manera, obtener un ahorro en el consumo energético.\par

La versatilidad de éste módulo, permitiría realizar estas decisiones mientras el sistema operativo se encuentra en funcionamiento, es decir que no sería necesario reiniciarlo para aplicar estos cambios.\par


\subsubsection{Primera Iteración: Implementación del módulo de encendido/apagado mediante cambios en la Red}

Para comenzar con la implementación del módulo se debatió el enfoque que le daríamos al desarrollo, es decir, si el cambio que debíamos generar iba a ser en las funciones del scheduler directamente o en la Red de Petri. Básicamente definir quién tomaría las decisiones.\par

Luego de observar con detenimiento el código, optamos por la modificación en la Red de Petri, ya que sería un cambio más favorable a futuro por los beneficios que se obtienen de un sistema de modelado como éste.\par

El primer acercamiento que se planteó fue el de crear algún indicador que permita conocer el estado de cada procesador, es decir, que tenga la información acerca de su estado, ya sea encendido o apagado.\par

Para representar esta idea dentro de la Red de Petri, se creó una plaza a la que se le dió el nombre de PLACE\_SUSPENDED. En el caso en que la misma se encuentre sin ningún token, se puede deducir que el procesador puede ser utilizado normalmente o que está disponible; caso contrario, el procesador no debería ejecutar ningún hilo.\par

La plaza de estado del procesador estará acompañada de dos transiciones encargadas de agregar o quitar el token correspondiente al estado del CPU en cuestión. La cantidad de tokens máxima que puede contener esta plaza, es de uno, ya que su funcionamiento refleja un comportamiento booleano. Para asegurar que esta lógica se cumpla, se agregó un arco inhibidor a la transición que aporta tokens a la plaza, es decir, una vez que agrega un token, ya no se disparará nuevamente hasta que este token sea eliminado por la transición correspondiente.\par

Esta plaza es la encargada de inhabilitar las transiciones de encolado correspondientes, la propia del CPU y la global. De esta forma cuando el CPU se encuentra suspendido, internamente se evita que algún hilo pueda ingresar a la cola y luego ejecutarse.\par

Un detalle que se debe tener en cuenta es que éste desarrollo, si bien evita que el procesador continúe encolando hilos, no elimina aquellos que ya se encontraban dentro de la cola asociada al CPU. En otras palabras, los hilos ya encolados, serán ejecutados en el momento correspondiente pero no podrán volver a la cola de este CPU inhabilitado.\par

Ésta aclaración se puede observar en la Red de Petri directamente, ya que la nueva plaza de suspensión sólo inhibe la transición de desencolado de la cola global y la transición encargada de agregar hilos a la cola del procesador, pero no interviene en las transiciones relacionadas a la ejecución de hilos, ni en la de desencolado propia del procesador (TRAN\_UNQUEUE).\par

% TODO{IMAGEN DE LA RED DE UN SOLO PROCESADOR CON EL SUSPEND PROC PERO SIN EL IDLE}

Como primer paso para la implementación a nivel código de esta funcionalidad, fue la modificación de las matrices (matriz base e incidencia) para dar soporte al cambio realizado en la red.\par

\renewcommand{\arraystretch}{1.5}
\setlength{\tabcolsep}{10pt}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
        \hline
        1 & 0 & -1 & 0 & 0 & 0 & 0 & -1 & 0 \\
        \hline
        1 & -1 & 0 & 0 & 0 & 0 & 0 & -1 & -1 \\
        \hline
        0 & -1 & 0 & 0 & 1 & 1 & -1 & 0 & 0 \\
        \hline
        0 & 1 & -1 & -1 & 0 & 0 & 1 & 0 & 0 \\
        \hline
        0 & 0 & 1 & 1 & -1 & -1 & 0 & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Matriz base previa a la nueva funcionalidad.}
    \label{tabla:matriz_base_pre}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
        1 & 0 & -1 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 \\
        \hline
        1 & -1 & 0 & 0 & 0 & 0 & 0 & -1 & -1 & 0 & 0 \\
        \hline
        0 & -1 & 0 & 0 & 1 & 1 & -1 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 1 & -1 & -1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 1 & 1 & -1 & -1 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 \\
        \hline
    \end{tabular}
    \caption{Matriz de incidencia base con modulo de encendido/apagado de procesadores.}
    \label{tabla:matriz_base_post}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
        \hline
        1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Matriz de incidencia previa a la nueva funcionalidad.}
    \label{tabla:matriz_incidencia_pre}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
        1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 \\
        \hline
    \end{tabular}
    \caption{Matriz de incidencia con las modificaciones pertinentes.}
    \label{tabla:matriz_incidencia_post}
\end{table}

Como complemento al cambio en las matrices, se agregó una función con la posibilidad de ser invocada desde un módulo de kernel, encargada de alternar el estado de un CPU elegido por el usuario que cargue el módulo en cuestión. Es decir, dentro de este módulo se elige el procesador a suspender o encender, luego se compila y carga el mismo.\par

Una vez implementada esta funcionalidad a nivel código, descubrimos que no funcionaba como se esperaba ya que recibimos alertas de transiciones no sensibilizadas con intentos de disparo.\par

Para resolverlo comenzamos imprimiendo en la terminal, la información relacionada a los disparos y  de esta manera descubrimos que el problema a solucionar estaba relacionado con el funcionamiento del scheduler para el caso en que no existan hilos a ejecutar en la cola propia ni en la global.\par

En el próximo apartado se explica cómo solucionamos esta problemática.\par


\subsubsection{Segunda Iteración: Soporte para el idlethread en la Red}

Partiendo de las impresiones en la terminal realizadas en el paso previo, se pudo identificar que se generaba un error en los casos en que un CPU no tenía hilos para ejecutar.\par

Para resolver esta problemática, es necesario entender que en casos como éste, el scheduler 4BSD, encola y ejecuta el idlethread. Este funcionamiento ya existía previamente al inicio del proyecto integrador; es propio del sistema operativo.\par

El idlethread representa un hilo dummy, es decir un hilo que no genera una carga para el procesador que lo ejecute. Es posible encolarlo, suspenderlo y ejecutarlo como cualquier otro hilo.\par

Cada núcleo del CPU tiene asociado su idlethread, el cual ejecuta continuamente un bucle simple que normalmente implica detener la CPU o ejecutar una instrucción de bajo consumo. De este modo, se asegura de que la CPU permanece ocupada incluso cuando no hay otras tareas o hilos listos para ejecutarse.\par

En lugar de permitir que un núcleo de CPU permanezca libre, FreeBSD lo mantiene ocupado con el idlethread. Este enfoque tiene beneficios que van desde un menor consumo de energía hasta mejoras en la capacidad de respuesta y en el rendimiento general del sistema.\par

Cuando no hay hilos o procesos ejecutables listos para ejecutarse en una CPU, el planificador selecciona el idlethread como el siguiente hilo a ejecutar. Este hilo es el que  tiene la prioridad más baja entre todos, por lo que sólo se programa cuando no hay otras tareas de mayor prioridad para ejecutar, y cualquier otro hilo lo reemplazará en caso de necesitar tiempo de procesador.\par

Partiendo de esta base pudimos concluir que nuestra Red de Petri planteada como modelo del planificador, no estaba representando correctamente lo que sucedía internamente. Por esto se decidió hacer ajustes en la red de recursos para contemplar este caso.\par

El problema surgía al intentar disparar la transición TRAN\_UNQUEUE del procesador suspendido ya que no existían hilos en la cola asociada al mismo. Pero el motivo por el cual se intentaba este disparo, es justamente por la funcionalidad ya integrada del idlethread, es decir, que el planificador desencola este hilo para mantener al núcleo del procesador activo. Por esto es que se observaba una inconsistencia con el modelo.\par

Para resolver esta problemática decidimos agregar una nueva transición (TRAN\_EXEC\_IDLE) que permite ejecutar el idlethread cuando no exista ningún hilo en la cola del procesador, incluyendo de esta forma, el caso en que el CPU se encuentre suspendido. Una vez aplicados estos cambios, el sistema representó fielmente el proceso interno llevado a cabo por el planificador.\par

% TODO{IMAGEN DE LA RED DE UN SOLO PROCESADOR CON EL SUSPEND PROC CON EL IDLE}

Para desarrollar esta actualización dentro del código se decidió realizar modificaciones de la Red de Petri de recursos, en las matrices base y de inhibición.\par

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
        1 &  0 & -1 &  0 & 0 & 0 & 0 & 0 & -1 & 0 & 0 & 0 \\
        \hline
        1 & -1 &  0 &  0 & 0 & 0 & 0 & 0 & -1 & -1 & 0 & 0 \\
        \hline
        0 & -1 &  0 &  0 & -1 & 1 & 1 & -1 & 0 & 0 & 0 & 0 \\
        \hline
        0 &  1 & -1 & -1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
        \hline
        0 &  0 &  1 &  1 & 0 & -1 & -1 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 &  0 &  0 &  0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & -1 \\
        \hline
    \end{tabular}
    \caption{Matriz base con las modificaciones pertinentes.}
    \label{tabla:matriz_base_post_2}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
        1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \hline
        1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 \\
        \hline
    \end{tabular}
    \caption{Matriz de incidencia con las modificaciones pertinentes.}
    \label{tabla:matriz_incidencia_post_2}
\end{table}

Además de modificar el archivo base de la Red de Petri, se agregaron cambios dentro de la función sched\_choose (encargada de indicar cuál es el mejor hilo a ejecutar) del planificador para que en los casos de CPU suspendido, el hilo elegido para pasar a ejecución sea el idlethread hasta que el procesador se activado nuevamente.\par

Para lograr esto, se consulta directamente a través de una función, si la plaza de suspensión del procesador que se encuentra ejecutando el código, contiene algún token. En caso de que esto sea verdadero, estaríamos ante la presencia de un procesador suspendido. Caso contrario el funcionamiento es el habitual.\par


\subsubsection{Resultados}

Una vez finalizado el desarrollo de esta nueva funcionalidad pudimos comenzar a realizar las pruebas pertinentes.\par

En resúmen, la funcionalidad propuesta para el planificador, que permite habilitar o inhabilitar núcleos del procesador, ha sido resuelta permitiendo así un control sobre los mismos que previamente no existía.\par

A su vez, se logró la versatilidad propuesta para este módulo, ya que es posible poner en funcionamiento esta mejora en tiempo real sin necesidad de reiniciar el sistema operativo.\par

Los detalles de los resultados serán explicados con mayor profundidad en el capítulo de
“Análisis de resultados”.\par

Un detalle a tener en cuenta es la imposibilidad de suspender el procesador cero. Esto es debido a que el sistema operativo utiliza este núcleo por defecto para tareas esenciales y al apagarlo, el sistema comienza a ralentizarse hasta que el kernel entra en pánico, resultando en un reinicio del mismo.\par

Para evitar que esta situación pueda darse, se realizaron los cambios necesarios en el código para prohibir la elección del núcleo en cuestión.\par


\subsubsection{Próximos pasos}

La implementación de este módulo no tiene mejoras o impacto inmediato en el sistema;  debido a que es un módulo independiente, activado mediante una señal enviada en un momento elegido por el desarrollador.\par

Observando a futuro, creemos que el próximo enfoque debería apuntar a una integración de esta funcionalidad con elementos propios del sistema operativo, tales como hilos, procesos o programas que controlen los mismos.\par

De esta forma se cambiaría el estado de los procesadores en tiempo real y de acuerdo a necesidades reales del sistema en conjunto; no solo a través de un módulo de kernel.\par

\
